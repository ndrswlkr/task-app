import { Readable } from 'node:stream';
import { CLI } from './cli.js';
import { Context } from './context.js';
import { Hooks } from './hooks.js';
import { Logger } from './logger.js';
import { Mime } from './mime.js';
import defaultConditionsPlugin from './plugins/default-conditions.js';
import defaultHelpersPlugin from './plugins/default-helpers.js';
import tmplEnginePlugin from './plugins/tmpl-engine.js';
import { Renderer } from './renderer.js';
import { Router } from './router.js';
import { ServerRequest } from './server/request.js';
import { ServerResponse } from './server/response.js';
import { Session } from './session.js';
import { Static } from './static.js';
import { UserAgent } from './user-agent.js';
import { MockUserAgent } from './user-agent/mock.js';
import { TestUserAgent } from './user-agent/test.js';
import { Validator } from './validator.js';
import Path from '@mojojs/path';
const ContextWrapper = class extends Context {
};
/**
 * Application class.
 */
export class App {
    constructor(options = {}) {
        /**
         * Command line interface.
         */
        this.cli = new CLI(this);
        /**
         * Default stash values.
         */
        this.defaults = {};
        /**
         * Application hooks.
         */
        this.hooks = new Hooks();
        /**
         * Application home directory.
         */
        this.home = new Path();
        /**
         * MIME types.
         */
        this.mime = new Mime();
        /**
         * Storage for user defined models.
         */
        this.models = {};
        /**
         * Application renderer.
         */
        this.renderer = new Renderer();
        /**
         * Application router.
         */
        this.router = new Router();
        /**
         * Encrypted cookie based session manager.
         */
        this.session = new Session(this);
        /**
         * Static file server.
         */
        this.static = new Static();
        /**
         * HTTP/WebSocket user agent.
         */
        this.ua = new UserAgent();
        /**
         * JSON schema validator.
         */
        this.validator = new Validator();
        this._contextClass = class extends ContextWrapper {
        };
        this.config = options.config ?? {};
        this.detectImport = options.detectImport ?? true;
        this.exceptionFormat = options.exceptionFormat ?? 'html';
        this.secrets = options.secrets ?? ['Insecure'];
        this.mode = options.mode ?? process.env.NODE_ENV ?? 'development';
        const isDev = this.mode === 'development';
        this.log = new Logger({ historySize: isDev ? 10 : 0, level: isDev ? 'trace' : 'info' });
        this.plugin(defaultHelpersPlugin);
        this.plugin(defaultConditionsPlugin);
        this.plugin(tmplEnginePlugin);
    }
    /**
     * Add an application hook to extend the framework.
     */
    addAppHook(name, fn) {
        this.hooks.addHook(name, fn);
        return this;
    }
    /**
     * Add a context hook to extend the framework.
     */
    addContextHook(name, fn) {
        this.hooks.addHook(name, fn);
        return this;
    }
    /**
     * Add a helper.
     */
    addHelper(name, fn) {
        return this.decorateContext(name, function (...args) {
            return fn(this, ...args);
        });
    }
    /**
     * Generate route matching any of the listed HTTP request methods or all.
     */
    any(...args) {
        return this.router.any(...args);
    }
    /**
     * Decorate context class with a method or getter/setter.
     */
    decorateContext(name, fn) {
        const proto = Context.prototype;
        if (Object.getOwnPropertyDescriptor(proto, name) != null) {
            throw new Error(`The name "${name}" is already used in the prototype chain`);
        }
        if (typeof fn !== 'function') {
            Object.defineProperty(this._contextClass.prototype, name, fn);
        }
        else {
            this._contextClass.prototype[name] = fn;
        }
        return this;
    }
    /**
     * Generate route matching only `DELETE` requests.
     */
    delete(...args) {
        return this.router.delete(...args);
    }
    /**
     * Generate route matching only `GET` requests.
     */
    get(...args) {
        return this.router.get(...args);
    }
    /**
     * Handle a new incoming request, used by servers.
     */
    async handleRequest(ctx) {
        if ((await this.hooks.runHook('dispatch:before', ctx)) === true)
            return;
        if (ctx.isWebSocket !== true && (await this.static.dispatch(ctx)) === true)
            return;
        if ((await this.hooks.runHook('router:before', ctx)) === true)
            return;
        if ((await this.router.dispatch(ctx)) === true)
            return;
        if (ctx.isWebSocket !== true)
            await ctx.notFound();
    }
    /**
     * Create a context for application.
     */
    newContext(req, res) {
        const ctx = new this._contextClass(this, req, res);
        Object.assign(ctx.stash, this.defaults);
        return ctx;
    }
    /**
     * Create a mock context for application. Very useful for testing helpers.
     */
    newMockContext(options = {}) {
        const ctx = new this._contextClass(this, new ServerRequest({
            body: new Readable(),
            headers: options.headers ?? [],
            isSecure: false,
            isWebSocket: false,
            method: options.method ?? 'GET',
            remoteAddress: '127.0.0.1',
            reverseProxy: false,
            url: options.url ?? '/'
        }), new ServerResponse(() => ctx.log.trace('Mock response has been sent')));
        Object.assign(ctx.stash, this.defaults);
        return ctx;
    }
    /**
     * Create a new mock user agent for application.
     */
    async newMockUserAgent(options, serverOptions) {
        return await MockUserAgent.newMockUserAgent(this, options, serverOptions);
    }
    /**
     * Create a new test user agent for application.
     */
    async newTestUserAgent(options, serverOptions) {
        return await TestUserAgent.newTestUserAgent(this, options, serverOptions);
    }
    /**
     * Generate route matching only `OPTIONS` requests.
     */
    options(...args) {
        return this.router.options(...args);
    }
    /**
     * Generate route matching only `PATCH` requests.
     */
    patch(...args) {
        return this.router.patch(...args);
    }
    /**
     * Register plugin.
     */
    plugin(plugin, options = {}) {
        return plugin(this, options);
    }
    /**
     * Generate route matching only `POST` requests.
     */
    post(...args) {
        return this.router.post(...args);
    }
    /**
     * Generate route matching only `PUT` requests.
     */
    put(...args) {
        return this.router.put(...args);
    }
    /**
     * Start the command line interface.
     */
    async start(command, ...args) {
        if (this.detectImport === true && process.argv[1] !== Path.callerFile().toString())
            return;
        return this.cli.start(command, ...args).catch(error => this.log.error(error.message));
    }
    /**
     * Generate route for a nested route with its own intermediate destination.
     */
    under(...args) {
        return this.router.under(...args);
    }
    /**
     * Warmup the cache, usually called automatically.
     */
    async warmup() {
        await Promise.all([this.static, this.renderer, this.router].map(component => component.warmup()));
        await this.hooks.runHook('app:warmup', this);
    }
    /**
     * Generate route matching only WebSocket handshake requests.
     */
    websocket(...args) {
        return this.router.websocket(...args);
    }
}
//# sourceMappingURL=app.js.map