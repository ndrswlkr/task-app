const HOP_BY_HOP = [
    'connection',
    'keep-alive',
    'proxy-authenticate',
    'proxy-authorization',
    'te',
    'trailer',
    'transfer-encoding',
    'upgrade'
];
/**
 * HTTP header class.
 */
export class Headers {
    constructor(init = []) {
        this._init = init;
    }
    /**
     * Append header value.
     */
    append(name, value) {
        const lowerCase = name.toLowerCase();
        const headers = this._getHeaders();
        if (headers[lowerCase] === undefined)
            return this.set(name, value);
        if (lowerCase === 'set-cookie') {
            headers[lowerCase].values.push(value);
        }
        else {
            headers[lowerCase].values = [[...headers[lowerCase].values, value].join(', ')];
        }
    }
    /**
     * Clone headers.
     */
    clone() {
        return new Headers(this.toArray());
    }
    /**
     * Remove hop-by-hop headers that should not be retransmitted.
     */
    dehop() {
        const headers = this._getHeaders();
        HOP_BY_HOP.forEach(name => delete headers[name]);
    }
    /**
     * Get header value.
     */
    get(name) {
        const header = this._getHeaders()[name.toLowerCase()];
        if (header === undefined)
            return null;
        return header.values.join(', ');
    }
    /**
     * Get all headers values individually.
     */
    getAll(name) {
        const values = this._getHeaders()[name.toLowerCase()]?.values ?? [];
        return [...values];
    }
    /**
     * Remove header.
     */
    remove(name) {
        delete this._getHeaders()[name.toLowerCase()];
    }
    /**
     * Set header value.
     */
    set(name, value) {
        const lowerCase = name.toLowerCase();
        this._getHeaders()[lowerCase] = { normalCase: name, values: [value] };
    }
    /**
     * Convert headers into a plain array of name/value pairs.
     */
    toArray() {
        const array = [];
        for (const header of Object.values(this._getHeaders())) {
            for (const value of header.values) {
                array.push(header.normalCase, value);
            }
        }
        return array;
    }
    /**
     * Convert headers into a plain object.
     */
    toObject() {
        const object = {};
        for (const header of Object.values(this._getHeaders())) {
            object[header.normalCase] = header.values.join(', ');
        }
        return object;
    }
    /**
     * Convert headers to string.
     */
    toString() {
        const lines = [];
        for (const header of Object.values(this._getHeaders())) {
            for (const value of header.values) {
                lines.push(`${header.normalCase}: ${value}\r\n`);
            }
        }
        return lines.join('') + '\r\n';
    }
    _getHeaders() {
        if (this._headers === undefined) {
            const headers = (this._headers = {});
            const init = this._init;
            for (let i = 0; i < init.length; i += 2) {
                const name = init[i];
                const value = init[i + 1];
                const lowerCase = name.toLowerCase();
                if (headers[lowerCase] === undefined) {
                    headers[lowerCase] = { normalCase: name, values: [value] };
                }
                else {
                    headers[lowerCase].values.push(value);
                }
            }
        }
        return this._headers;
    }
}
//# sourceMappingURL=headers.js.map