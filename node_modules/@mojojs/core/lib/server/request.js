import { Body } from '../body.js';
import { Params } from '../body/params.js';
import { parseCookie } from '../server/cookie.js';
import { decodeURIComponentSafe } from '@mojojs/util';
// Official regex from RFC 3986
const URL_RE = /^(([^:/?#]+):)?(\/\/([^/?#]*))?([^?#]*)(\?([^#]*))?(#(.*))?/;
let requestId = 0;
/**
 * Server request class.
 */
export class ServerRequest extends Body {
    constructor(options) {
        super(options.headers, options.body);
        /**
         * Request base path.
         */
        this.basePath = '';
        /**
         * Request path.
         */
        this.path = '/';
        this._cookies = undefined;
        this._ip = undefined;
        this._protocol = undefined;
        this._query = undefined;
        this._userinfo = undefined;
        this.method = options.method ?? null;
        const url = (this.url = options.url ?? null);
        const pathMatch = (url ?? '').match(URL_RE);
        this.path = pathMatch === null ? '' : decodeURIComponentSafe(pathMatch[5]) ?? '';
        this.isWebSocket = options.isWebSocket;
        this.isSecure = options.isSecure;
        requestId = (requestId + 1) & 2147483647;
        this.requestId = `${process.pid}-${requestId.toString(36).padStart(6, '0')}`;
        this.remoteAddress = options.remoteAddress ?? null;
        this.reverseProxy = options.reverseProxy;
    }
    /**
     * Server base URL.
     */
    get baseURL() {
        return `${this.protocol}://${this.get('Host') ?? ''}`;
    }
    /**
     * Get cookie value.
     */
    getCookie(name) {
        if (this._cookies === undefined) {
            const header = this.get('Cookie');
            this._cookies = header === null ? {} : parseCookie(header);
        }
        return this._cookies[name] ?? null;
    }
    /**
     * Remote IP address. Uses he `X-Forwarded-For` header value if reverse proxy support is activated.
     */
    get ip() {
        if (this._ip === undefined) {
            this._ip = this.remoteAddress;
            if (this.reverseProxy === true) {
                const forwarded = this.get('X-Forwarded-For');
                if (forwarded !== null) {
                    const match = forwarded.match(/([^,\s]+)$/);
                    if (match !== null)
                        this._ip = match[1];
                }
            }
        }
        return this._ip;
    }
    /**
     * Request protocol. Uses the `X-Forwarded-Proto` header value if reverse proxy support is activated.
     */
    get protocol() {
        if (this._protocol === undefined) {
            this._protocol = this.isSecure ? 'https' : 'http';
            if (this.reverseProxy === true) {
                const forwarded = this.get('X-Forwarded-Proto');
                if (forwarded !== null)
                    this._protocol = forwarded;
            }
        }
        return this._protocol;
    }
    /**
     * Query parameters.
     */
    get query() {
        if (this._query === undefined) {
            const url = this.url ?? '';
            if (url.includes('?') === true) {
                const match = url.match(URL_RE);
                this._query = match !== null ? new Params(match[7]) : new Params();
            }
            else {
                this._query = new Params();
            }
        }
        return this._query;
    }
    /**
     * User info.
     */
    get userinfo() {
        if (this._userinfo === undefined) {
            this._userinfo = null;
            const auth = this.get('Authorization');
            if (auth !== null) {
                const match = auth.match(/Basic (.+)$/);
                if (match !== null)
                    this._userinfo = Buffer.from(match[1], 'base64').toString();
            }
        }
        return this._userinfo;
    }
}
//# sourceMappingURL=request.js.map