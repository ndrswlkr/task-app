/// <reference types="node" />
/// <reference types="node" />
/// <reference types="tap" />
/// <reference types="node" />
import type { App } from '../app.js';
import type { JSONValue, ServerOptions, TestUserAgentOptions, UserAgentRequestOptions, UserAgentWebSocketOptions } from '../types.js';
import type { WebSocket } from '../websocket.js';
import type { UserAgentResponse } from './response.js';
import type { URL } from 'node:url';
import assert from 'node:assert/strict';
import { MockUserAgent } from './mock.js';
import DOM from '@mojojs/dom';
import StackUtils from 'stack-utils';
type SkipFunction = (...args: any[]) => any;
/**
 * Test user agent class.
 */
export declare class TestUserAgent extends MockUserAgent {
    /**
     * Current HTTP response content.
     */
    body: Buffer;
    _assert: typeof assert | Tap.Test | undefined;
    _dom: DOM | undefined;
    _finished: [number, string] | null | undefined;
    _messages: AsyncIterableIterator<JSONValue> | undefined;
    _res: UserAgentResponse | undefined;
    _stack: StackUtils;
    _ws: WebSocket | undefined;
    constructor(options?: TestUserAgentOptions);
    /**
     * Delegate assertion to test framework currently in use.
     */
    assert(name: string, args: any[], msg: string, skip: SkipFunction): void;
    /**
     * Check response content for exact match.
     */
    bodyIs(body: string): this;
    /**
     * Opposite of `bodyIs`.
     */
    bodyIsnt(body: string): this;
    /**
     * Check response content for similar match.
     */
    bodyLike(regex: RegExp): this;
    /**
     * Opposite of `bodyLike`.
     */
    bodyUnlike(regex: RegExp): this;
    /**
     * Close WebSocket connection gracefully.
     */
    closeOk(code: number, reason: string): Promise<void>;
    /**
     * Wait for WebSocket connection to be closed gracefully and check status.
     */
    closedOk(code: number): Promise<void>;
    /**
     * Perform a `DELETE` request and check for transport errors.
     */
    deleteOk(url: string | URL, options?: UserAgentRequestOptions): Promise<this>;
    /**
     * Checks for existence of the CSS selectors first matching HTML/XML element.
     */
    elementExists(selector: string): this;
    /**
     * Opposite of `elementExists`.
     */
    elementExistsNot(selector: string): this;
    /**
     * Perform a `GET` request and check for transport errors.
     */
    getOk(url: string | URL, options?: UserAgentRequestOptions): Promise<this>;
    /**
     * Perform a `HEAD` request and check for transport errors.
     */
    headOk(url: string | URL, options?: UserAgentRequestOptions): Promise<this>;
    /**
     * Check if response header exists.
     */
    headerExists(name: string): this;
    /**
     * Opposite of `headerExists`.
     */
    headerExistsNot(name: string): this;
    /**
     * Check response header for exact match.
     */
    headerIs(name: string, value: string): this;
    /**
     * Opposite of `headerIs`.
     */
    headerIsnt(name: string, value: string): this;
    /**
     * Check response header for similar match.
     */
    headerLike(name: string, regex: RegExp): this;
    /**
     * Check if JSON response contains a value that can be identified using the given JSON Pointer.
     */
    jsonHas(pointer: string): this;
    /**
     * Check the value extracted from JSON response using the given JSON Pointerr, which defaults to the root value if it
     * is omitted.
     */
    jsonIs(value: JSONValue, pointer?: string): this;
    /**
     * Wait for next WebSocket message to arrive.
     */
    messageOk(): Promise<JSONValue>;
    /**
     * Create a new test user agent.
     */
    static newTestUserAgent(app: App, options?: TestUserAgentOptions, serverOptions?: ServerOptions): Promise<TestUserAgent>;
    /**
     * Perform a `OPTIONS` request and check for transport errors.
     */
    optionsOk(url: string | URL, options?: UserAgentRequestOptions): Promise<this>;
    /**
     * Perform a `PATCH` request and check for transport errors.
     */
    patchOk(url: string | URL, options?: UserAgentRequestOptions): Promise<this>;
    /**
     * Perform a `POST` request and check for transport errors.
     */
    postOk(url: string | URL, options?: UserAgentRequestOptions): Promise<this>;
    /**
     * Perform a `PUT` request and check for transport errors.
     */
    putOk(url: string | URL, options?: UserAgentRequestOptions): Promise<this>;
    /**
     * Current HTTP response.
     */
    get res(): UserAgentResponse;
    /**
     * Send message or frame via WebSocket.
     */
    sendOk(message: any): Promise<void>;
    /**
     * Check response status for exact match.
     */
    statusIs(status: number): this;
    /**
     * Checks text content of the CSS selectors first matching HTML/XML element for similar match.
     */
    textLike(selector: string, regex: RegExp): this;
    /**
     * Check response `Content-Type` header for exact match.
     */
    typeIs(value: string): this;
    /**
     * Check response `Content-Type` header for similar match.
     */
    typeLike(regex: RegExp): this;
    /**
     * Open a WebSocket connection with transparent handshake.
     */
    websocketOk(url: string | URL, options?: UserAgentWebSocketOptions): Promise<void>;
    /**
     * Active WebSocket connection.
     */
    get ws(): WebSocket;
    /**
     * Check if YAML response contains a value that can be identified using the given JSON Pointer.
     */
    yamlHas(pointer: string): this;
    /**
     * Check the value extracted from YAML response using the given JSON Pointerr, which defaults to the root value if it
     * is omitted.
     */
    yamlIs(value: JSONValue, pointer?: string): this;
    get _html(): DOM;
    _prepareTap(tap: Tap.Test): void;
    _requestOk(skip: SkipFunction, method: string, url: string | URL, options?: UserAgentRequestOptions): Promise<this>;
    _waitFinished(): Promise<void>;
}
export {};
