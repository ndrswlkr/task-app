import { CDATANode } from './nodes/cdata.js';
import { CommentNode } from './nodes/comment.js';
import { DoctypeNode } from './nodes/doctype.js';
import { DocumentNode } from './nodes/document.js';
import { ElementNode } from './nodes/element.js';
import { PINode } from './nodes/pi.js';
import { stickyMatch, xmlUnescape } from '@mojojs/util';
const ATTR_RE = new RegExp(`([^<>=\\s/]+|/)(?:\\s*=\\s*(?:(?<quote>["'])(.*?)\\k<quote>|([^>\\s]*)))?\\s*`, 'ys');
const TEXT_RE = new RegExp(`([^<]+)`, 'ys');
const DOCTYPE_RE = new RegExp(`<!DOCTYPE\\s*(\\w+(?:(?:\\s+\\w+)?(?:\\s+(?:"[^"]*"|'[^']*'))+)?(?:\\s+\\[.+?\\])?\\s*)>`, 'ysi');
const COMMENT_RE = new RegExp(`<!--(.*?)--\\s*>`, 'ys');
const CDATA_RE = new RegExp(`<!\\[CDATA\\[(.*?)\\]\\]>`, 'ysi');
const PI_RE = new RegExp(`<\\?(.*?)\\?>`, 'ys');
const TAG_RE = new RegExp(`<\\s*(\\/)?\\s*([^<>\\s]+)\\s*((?:${ATTR_RE.source})*)>`, 'ys');
const RUNAWAY_RE = new RegExp(`<`, 'y');
// HTML elements that only contain raw text
const RAW = new Set(['script', 'style']);
// HTML elements that only contain raw text and entities
const CDATA = new Set(['title', 'textarea']);
// HTML elements with optional end tags and elements that break paragraphs
const END = {
    address: 'p',
    article: 'p',
    aside: 'p',
    blockquote: 'p',
    body: 'head',
    optgroup: 'optgroup',
    option: 'option',
    details: 'p',
    dialog: 'p',
    div: 'p',
    dl: 'p',
    fieldset: 'p',
    figcaption: 'p',
    figure: 'p',
    footer: 'p',
    form: 'p',
    h1: 'p',
    h2: 'p',
    h3: 'p',
    h4: 'p',
    h5: 'p',
    h6: 'p',
    header: 'p',
    hgroup: 'p',
    hr: 'p',
    main: 'p',
    menu: 'p',
    nav: 'p',
    ol: 'p',
    p: 'p',
    pre: 'p',
    section: 'p',
    table: 'p',
    ul: 'p'
};
// Container HTML elements that create their own scope
const SCOPE = new Set(['math', 'svg']);
// HTML table elements with optional end tags
const TABLE = new Set(['colgroup', 'tbody', 'td', 'tfoot', 'th', 'thead', 'tr']);
// HTML elements with optional end tags and scoping rules
const CLOSE = {
    li: { allowed: new Set(['li']), scope: new Set(['ul', 'ol']) },
    tr: { allowed: new Set(['tr']), scope: new Set(['table']) },
    colgroup: { allowed: TABLE, scope: new Set(['table']) },
    tbody: { allowed: TABLE, scope: new Set(['table']) },
    tfoot: { allowed: TABLE, scope: new Set(['table']) },
    thead: { allowed: TABLE, scope: new Set(['table']) },
    dd: { allowed: new Set(['dd', 'dt']), scope: new Set(['dl']) },
    dt: { allowed: new Set(['dd', 'dt']), scope: new Set(['dl']) },
    rp: { allowed: new Set(['rp', 'rt']), scope: new Set(['dl']) },
    rt: { allowed: new Set(['rp', 'rt']), scope: new Set(['dl']) },
    td: { allowed: new Set(['th', 'td']), scope: new Set(['table']) },
    th: { allowed: new Set(['th', 'td']), scope: new Set(['table']) }
};
// HTML parent elements that signal no more content when closed, but that are also phrasing content
const NO_MORE_CONTENT = {
    ruby: new Set(['rt', 'rp']),
    select: new Set(['option', 'optgroup'])
};
// HTML elements without end tags
const EMPTY = new Set([
    'area',
    'base',
    'br',
    'col',
    'embed',
    'hr',
    'img',
    'input',
    'keygen',
    'link',
    'menuitem',
    'meta',
    'param',
    'source',
    'track',
    'wbr'
]);
// HTML elements categorized as phrasing content (and obsolete inline elements)
const OBSOLETE = ['acronym', 'applet', 'basefont', 'big', 'font', 'strike', 'tt'];
const PHRASING = new Set([
    ...OBSOLETE,
    'a',
    'abbr',
    'area',
    'audio',
    'b',
    'bdi',
    'bdo',
    'br',
    'button',
    'canvas',
    'cite',
    'code',
    'data',
    'datalist',
    'del',
    'dfn',
    'em',
    'embed',
    'i',
    'iframe',
    'img',
    'input',
    'ins',
    'kbd',
    'keygen',
    'label',
    'link',
    'map',
    'mark',
    'math',
    'meta',
    'meter',
    'noscript',
    'object',
    'output',
    'picture',
    'progress',
    'q',
    'ruby',
    's',
    'samp',
    'script',
    'select',
    'slot',
    'small',
    'span',
    'strong',
    'sub',
    'sup',
    'svg',
    'template',
    'textarea',
    'time',
    'u',
    'var',
    'video',
    'wbr'
]);
// HTML elements that don't get their self-closing flag acknowledged
const BLOCK = new Set([
    'a',
    'address',
    'applet',
    'article',
    'aside',
    'b',
    'big',
    'blockquote',
    'body',
    'button',
    'caption',
    'center',
    'code',
    'col',
    'colgroup',
    'dd',
    'details',
    'dialog',
    'dir',
    'div',
    'dl',
    'dt',
    'em',
    'fieldset',
    'figcaption',
    'figure',
    'font',
    'footer',
    'form',
    'frameset',
    'h1',
    'h2',
    'h3',
    'h4',
    'h5',
    'h6',
    'head',
    'header',
    'hgroup',
    'html',
    'i',
    'iframe',
    'li',
    'listing',
    'main',
    'marquee',
    'menu',
    'nav',
    'nobr',
    'noembed',
    'noframes',
    'noscript',
    'object',
    'ol',
    'optgroup',
    'option',
    'p',
    'plaintext',
    'pre',
    'rp',
    'rt',
    's',
    'script',
    'section',
    'select',
    'small',
    'strike',
    'strong',
    'style',
    'summary',
    'table',
    'tbody',
    'td',
    'template',
    'textarea',
    'tfoot',
    'th',
    'thead',
    'title',
    'tr',
    'tt',
    'u',
    'ul',
    'xmp'
]);
export class XMLParser {
    parse(xml) {
        const doc = new DocumentNode();
        let current = doc;
        const sticky = { offset: 0, value: xml };
        while (xml.length > sticky.offset) {
            // Text
            const textMatch = stickyMatch(sticky, TEXT_RE);
            if (textMatch !== null) {
                current.insertText(xmlUnescape(textMatch[1]));
                continue;
            }
            // DOCTYPE
            const doctypeMatch = stickyMatch(sticky, DOCTYPE_RE);
            if (doctypeMatch !== null) {
                current.appendChild(new DoctypeNode(doctypeMatch[1], '', ''));
                continue;
            }
            // Comment
            const commentMatch = stickyMatch(sticky, COMMENT_RE);
            if (commentMatch !== null) {
                current.appendChild(new CommentNode(commentMatch[1]));
                continue;
            }
            // CDATA
            const cdataMatch = stickyMatch(sticky, CDATA_RE);
            if (cdataMatch !== null) {
                current.appendChild(new CDATANode(cdataMatch[1]));
                continue;
            }
            // Processing instruction
            const piMatch = stickyMatch(sticky, PI_RE);
            if (piMatch !== null) {
                current.appendChild(new PINode(piMatch[1]));
                continue;
            }
            // Tag
            const tagMatch = stickyMatch(sticky, TAG_RE);
            if (tagMatch !== null) {
                const tag = tagMatch[2];
                // Start
                if (tagMatch[1] === undefined) {
                    const attrs = {};
                    const unparsed = tagMatch[3];
                    let close = false;
                    if (unparsed !== undefined) {
                        // Attributes
                        const stickyAttr = { offset: 0, value: unparsed };
                        while (unparsed.length > stickyAttr.offset) {
                            const attrMatch = stickyMatch(stickyAttr, ATTR_RE);
                            if (attrMatch === null)
                                break;
                            const name = attrMatch[1];
                            if (name === '/') {
                                close = true;
                            }
                            else {
                                attrs[name] = xmlUnescape(attrMatch[3] ?? attrMatch[4] ?? '');
                            }
                        }
                    }
                    current.appendChild((current = new ElementNode(tag, '', attrs)));
                    // Element without end tag (self-closing)
                    if (close === true)
                        current = this._end(current, tag);
                }
                // End
                else {
                    current = this._end(current, tag);
                }
                continue;
            }
            // Runaway "<"
            const runawayMatch = stickyMatch(sticky, RUNAWAY_RE);
            if (runawayMatch !== null) {
                current.insertText('<');
                continue;
            }
            break;
        }
        return doc;
    }
    _end(current, tag) {
        let node = current;
        while (node !== null) {
            const parent = node.parentNode;
            if (parent === null)
                break;
            if (node.nodeType === '#element' && node.tagName === tag)
                return parent;
            node = parent;
        }
        return current;
    }
}
//# sourceMappingURL=xml.js.map