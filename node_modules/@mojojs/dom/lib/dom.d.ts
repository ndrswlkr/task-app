/*!
 * dom.js
 * Copyright (C) 2021-2022 Sebastian Riedel
 * MIT Licensed
 */
import type { Child, DOMParser, Parent } from './types.js';
import { CDATANode } from './nodes/cdata.js';
import { CommentNode } from './nodes/comment.js';
import { DoctypeNode } from './nodes/doctype.js';
import { DocumentNode } from './nodes/document.js';
import { ElementNode } from './nodes/element.js';
import { FragmentNode } from './nodes/fragment.js';
import { PINode } from './nodes/pi.js';
import { TextNode } from './nodes/text.js';
import { SafeString } from '@mojojs/util';
export * from '@mojojs/util';
export { CDATANode, CommentNode, DoctypeNode, DocumentNode, ElementNode, FragmentNode, PINode, TextNode };
type FormValue = string | string[] | null | FormValue[];
/**
 * HTML/XML DOM API class.
 */
export default class DOM {
    /**
     * Current node in the DOM tree.
     */
    currentNode: Parent;
    _xml: boolean;
    constructor(input: string | Parent, options?: {
        fragment?: boolean;
        parser?: DOMParser;
        xml?: boolean;
    });
    /**
     * Ancestor elements of this element.
     */
    ancestors(selector?: string): DOM[];
    /**
     * Append HTML/XML fragment to this element.
     */
    append(content: string | DOM): this;
    /**
     * Append HTML/XML fragment to this element's content.
     */
    appendContent(content: string | DOM): this;
    /**
     * Find first descendant element of this element matching the CSS selector.
     */
    at(selector: string): DOM | null;
    /**
     * This element's attributes.
     */
    get attr(): Record<string, string>;
    /**
     * Child elements of this element.
     */
    children(selector?: string): DOM[];
    /**
     * This element's rendered content.
     */
    content(): string;
    /**
     * Find all descendant elements of this element matching the CSS selector.
     */
    find(selector: string): DOM[];
    /**
     * Sibling elements after this element.
     */
    following(selector?: string): DOM[];
    /**
     * Find this element's namespace.
     */
    namespace(): string | null;
    /**
     * Check if this element matches the CSS selector.
     */
    matches(selector: string): boolean;
    /**
     * Sibling element after this element.
     */
    next(): DOM | null;
    /**
     * Create a new `DOM` object with one tag.
     */
    static newTag(name: string, attrs?: Record<string, string | boolean | Record<string, string>> | string | SafeString, content?: string | SafeString): DOM;
    /**
     * Parent of this element.
     */
    parent(): DOM | null;
    /**
     * Sibling elements before this element.
     */
    preceding(selector?: string): DOM[];
    /**
     * Prepend HTML/XML fragment to this element.
     */
    prepend(content: string | DOM): this;
    /**
     * Prepend HTML/XML fragment to this element's content.
     */
    prependContent(content: string | DOM): this;
    /**
     * Sibling element before this element.
     */
    previous(): DOM | null;
    /**
     * Remove this element and its children.
     */
    remove(): void;
    /**
     * Replace this element with HTML/XML fragment.
     */
    replace(content: string | DOM): void;
    /**
     * Replace this element's content with HTML/XML fragment.
     */
    replaceContent(content: string | DOM): void;
    /**
     * Root node.
     */
    root(): DOM | null;
    /**
     * Get a unique CSS selector for this element.
     */
    selector(): string | null;
    /**
     * Remove this element while preserving its content.
     */
    strip(): void;
    /**
     * This element's tag name.
     */
    get tag(): string;
    set tag(name: string);
    /**
     * Extract text content from this element.
     */
    text(options?: {
        recursive: boolean;
    }): string;
    /**
     * Render DOM to HTML or XML.
     */
    toString(options?: {
        xml: boolean;
    }): string;
    /**
     * Extract value from form element (such as `<button>`, `<input>`, `<option>`, `<select>` and `<textarea>`), or
     * return `null` if this element has no value. In the case of `<select>` with `multiple` attribute, find `<option>`
     * elements with `selected` attribute and return an array with all values, or `null` if none could be found.
     */
    val(): FormValue;
    /**
     * Wrap HTML/XML fragment around this element.
     */
    wrap(content: string | DOM): void;
    /**
     * Wrap HTML/XML fragment around the content of this element.
     */
    wrapContent(content: string | DOM): void;
    _addChild(content: string | DOM, before: boolean): this;
    _addSibling(contentNode: Parent, before: boolean): this;
    _ensureNode(content: string | DOM): Parent;
    _extractNodes(current: Parent): Child[];
    _filter(selector: string | undefined, elements: DOM[]): DOM[];
    _innermostElement(node: Parent): Parent;
    _newDOM(node: Parent): DOM;
    _wrap(content: string | DOM, outer: boolean): void;
}
