import fs from 'node:fs';
import fsPromises from 'node:fs/promises';
import os from 'node:os';
import path from 'node:path';
import readline from 'node:readline';
import url from 'node:url';
import StackUtils from 'stack-utils';
export default class Path {
    /**
     * Create a `Path` instance for the given path or the current working directory.
     * @example
     * // Relative file
     * const file = new Path('work', 'notes.txt');
     *
     * // Current working directory
     * const dir = new Path();
     */
    constructor(...parts) {
        this._path = parts.length === 0 ? process.cwd() : parts.length === 1 ? parts[0] : path.join(...parts);
    }
    /**
     * Asynchronously tests a user's permissions for the file or directory.
     * @see https://nodejs.org/api/fs.html#fs_fspromises_access_path_mode
     */
    async access(mode) {
        return await fsPromises.access(this._path, mode).then(() => true, () => false);
    }
    /**
     * Synchronously tests a user's permissions for the file or directory.
     * @see https://nodejs.org/api/fs.html#fs_fs_accesssync_path_mode
     */
    accessSync(mode) {
        try {
            fs.accessSync(this._path, mode);
            return true;
        }
        catch (error) {
            return false;
        }
    }
    /**
     * Asynchronously append data to a file, creating the file if it does not yet exist.
     * @see https://nodejs.org/api/fs.html#filehandleappendfiledata-options
     */
    async appendFile(data, options) {
        await fsPromises.appendFile(this._path, data, options);
        return this;
    }
    /**
     * Synchronously append data to a file, creating the file if it does not yet exist.
     * @see https://nodejs.org/api/fs.html#fsappendfilesyncpath-data-options
     */
    appendFileSync(data, options) {
        fs.appendFileSync(this._path, data, options);
        return this;
    }
    /**
     * Returns the last portion of a path, similar to the Unix `basename` command.
     * @see https://nodejs.org/api/path.html#path_path_basename_path_ext
     */
    basename(ext) {
        return path.basename(this._path, ext);
    }
    /**
     * Create a new `Path` object for the caller source file.
     */
    static callerFile() {
        return Path.fromFileURL(new StackUtils().capture(3)[2].getFileName() ?? '');
    }
    /**
     * Create a new `Path` object relative to the current path.
     * @example
     * // "/home/kraih/notes.txt"
     * const home = new Path('/home/kraih');
     * const file = home.child('notes.txt');
     */
    child(...parts) {
        return new Path(this._path, ...parts);
    }
    /**
     * Asynchronously changes the permissions of a file.
     * @see https://nodejs.org/api/fs.html#fs_fspromises_chmod_path_mode
     */
    async chmod(mode) {
        await fsPromises.chmod(this._path, mode);
        return this;
    }
    /**
     * Synchronously changes the permissions of a file.
     * @see https://nodejs.org/api/fs.html#fs_fs_chmodsync_path_mode
     */
    chmodSync(mode) {
        fs.chmodSync(this._path, mode);
        return this;
    }
    /**
     * Asynchronously change the ownership of a file.
     * @see https://nodejs.org/api/fs.html#fspromiseschownpath-uid-gid
     */
    async chown(uid, gid) {
        await fsPromises.chown(this._path, uid, gid);
        return this;
    }
    /**
     * Synchronously change the ownership of a file.
     * @see https://nodejs.org/api/fs.html#fschownsyncpath-uid-gid
     */
    chownSync(uid, gid) {
        fs.chownSync(this._path, uid, gid);
        return this;
    }
    /**
     * Returns an object containing commonly used constants for file system operations.
     * @see https://nodejs.org/api/fs.html#fs_fs_constants
     */
    static get constants() {
        return fs.constants;
    }
    /**
     * Asynchronously copies file to destination.
     * @see https://nodejs.org/api/fs.html#fs_fspromises_copyfile_src_dest_mode
     */
    async copyFile(destination, flags) {
        await fsPromises.copyFile(this._path, destination.toString(), flags);
        return this;
    }
    /**
     * Synchronously copies file to destination.
     * @see https://nodejs.org/api/fs.html#fs_fs_copyfilesync_src_dest_mode
     */
    copyFileSync(destination, flags) {
        fs.copyFileSync(this._path, destination.toString(), flags);
        return this;
    }
    /**
     * Create a readable stream for file.
     * @see https://nodejs.org/api/fs.html#fs_fs_createreadstream_path_options
     */
    createReadStream(options) {
        return fs.createReadStream(this._path, options);
    }
    /**
     * Create a writable stream for file.
     * @see https://nodejs.org/api/fs.html#fs_fs_createwritestream_path_options
     */
    createWriteStream(options) {
        return fs.createWriteStream(this._path, options);
    }
    /**
     * Create a new `Path` object for the current source file.
     */
    static currentFile() {
        return Path.fromFileURL(new StackUtils().capture(2)[1].getFileName() ?? '');
    }
    /**
     * Returns the directory name of a path, similar to the Unix `dirname` command.
     * @see https://nodejs.org/api/path.html#path_path_dirname_path
     */
    dirname() {
        return new Path(path.dirname(this._path));
    }
    /**
     * Asynchronously check if file or directory exists.
     */
    async exists() {
        return await this.access(fs.constants.F_OK);
    }
    /**
     * Synchronously check if file or directory exists.
     */
    existsSync() {
        return this.accessSync(fs.constants.F_OK);
    }
    /**
     * Returns the extension of the path, from the last occurrence of the `.` (period) character to end of string in the
     * last portion of the path.
     * @see https://nodejs.org/api/path.html#path_path_extname_path
     */
    extname() {
        return path.extname(this._path);
    }
    /**
     * Create a new `Path` object from a `file://` URL.
     */
    static fromFileURL(file) {
        return new Path(url.fileURLToPath(file));
    }
    /**
     * Determine if path is an absolute path.
     * @see https://nodejs.org/api/path.html#path_path_isabsolute_path
     */
    isAbsolute() {
        return path.isAbsolute(this._path);
    }
    /**
     * Asynchronously check if file is readable.
     */
    async isReadable() {
        return await this.access(fs.constants.R_OK);
    }
    /**
     * Synchronously check if file is readable.
     */
    isReadableSync() {
        return this.accessSync(fs.constants.R_OK);
    }
    /**
     * Asynchronously check if file is writable.
     */
    async isWritable() {
        return await this.access(fs.constants.W_OK);
    }
    /**
     * Synchronously check if file is writable.
     */
    isWritableSync() {
        return this.accessSync(fs.constants.W_OK);
    }
    /**
     * List files in directory.
     * @example
     * // List files recursively
     * const dir = new Path('/tmp');
     * for await (const file of dir.list({recursive: true})) {
     *   console.log(file.toString());
     * }
     */
    async *list(options = {}) {
        const files = await fsPromises.readdir(this._path, { withFileTypes: true });
        const maxDepth = options.maxDepth;
        for (const file of files) {
            if (options.hidden !== true && file.name.startsWith('.'))
                continue;
            const full = path.resolve(this._path, file.name);
            if (file.isDirectory()) {
                if (options.dir === true)
                    yield new Path(full);
                if (options.recursive === true && options.maxDepth !== 1) {
                    yield* new Path(full).list(maxDepth === undefined ? options : { ...options, maxDepth: maxDepth - 1 });
                }
            }
            else {
                yield new Path(full);
            }
        }
    }
    /**
     * Read file one line at a time.
     * @example
     * // Decode UTF-8 file
     * const file = new Path('notes.txt');
     * for await (const line of file.lines({encoding: 'utf8'})) {
     *   console.log(line);
     * }
     */
    lines(options) {
        return readline.createInterface({ input: this.createReadStream(options), crlfDelay: Infinity });
    }
    /**
     * Equivalent to `stat` unless path refers to a symbolic link, in which case the link itself is stat-ed, not the file
     * that it refers to.
     * @see https://nodejs.org/api/fs.html#fs_fspromises_lstat_path_options
     */
    async lstat(options) {
        return await fsPromises.lstat(this._path, options);
    }
    /**
     * Equivalent to `statSync` unless path refers to a symbolic link, in which case the link itself is stat-ed, not the
     * file that it refers to.
     * @see https://nodejs.org/api/fs.html#fs_fs_lstatsync_path_options
     */
    lstatSync(options) {
        return fs.lstatSync(this._path, options);
    }
    /**
     * Asynchronously creates a directory.
     * @see https://nodejs.org/api/fs.html#fs_fspromises_mkdir_path_options
     */
    async mkdir(options) {
        await fsPromises.mkdir(this._path, options);
        return this;
    }
    /**
     * Synchronously creates a directory.
     * @see https://nodejs.org/api/fs.html#fs_fs_mkdirsync_path_options
     */
    mkdirSync(options) {
        fs.mkdirSync(this._path, options);
        return this;
    }
    /**
     * Normalizes the given path, resolving `..` and `.` segments.
     * @see https://nodejs.org/api/path.html#path_path_normalize_path
     */
    normalize() {
        return new Path(path.normalize(this._path));
    }
    /**
     * Asynchronously open file.
     * @see https://nodejs.org/api/fs.html#fs_fspromises_open_path_flags_mode
     */
    async open(flags, mode) {
        return await fsPromises.open(this._path, flags, mode);
    }
    /**
     * Asynchronously reads the entire contents of a file.
     * @see https://nodejs.org/api/fs.html#fs_fspromises_readfile_path_options
     */
    async readFile(options) {
        return await fsPromises.readFile(this._path, options);
    }
    /**
     * Synchronously reads the entire contents of a file.
     * @see https://nodejs.org/api/fs.html#fs_fs_readfilesync_path_options
     */
    readFileSync(options) {
        return fs.readFileSync(this._path, options);
    }
    /**
     * Returns the relative path from path to `to` based on the current working directory.
     * @see https://nodejs.org/api/path.html#path_path_relative_from_to
     */
    relative(to) {
        return new Path(path.relative(this._path, to.toString()));
    }
    /**
     * Asynchronously renames path to `newPath`.
     * @see https://nodejs.org/api/fs.html#fs_fspromises_rename_oldpath_newpath
     */
    async rename(newPath) {
        return await fsPromises.rename(this._path, newPath.toString());
    }
    /**
     * Synchronously renames path to `newPath`.
     * @see https://nodejs.org/api/fs.html#fs_fs_renamesync_oldpath_newpath
     */
    renameSync(newPath) {
        fs.renameSync(this._path, newPath.toString());
    }
    /**
     * Asynchronously computes the canonical pathname.
     * @see https://nodejs.org/api/fs.html#fs_fspromises_realpath_path_options
     */
    async realpath(options) {
        return await fsPromises.realpath(this._path, options).then(path => new Path(path));
    }
    /**
     * Synchronously computes the canonical pathname.
     * @see https://nodejs.org/api/fs.html#fs_fs_realpathsync_path_options
     */
    realpathSync(options) {
        return new Path(fs.realpathSync(this._path, options));
    }
    /**
     * Asynchronously removes files and directories (modeled on the standard POSIX `rm` utility).
     * @see https://nodejs.org/api/fs.html#fs_fspromises_rm_path_options
     */
    async rm(options) {
        return await fsPromises.rm(this._path, options);
    }
    /**
     * Synchronously removes files and directories (modeled on the standard POSIX `rm` utility).
     * @see https://nodejs.org/api/fs.html#fs_fs_rmsync_path_options
     */
    rmSync(options) {
        fs.rmSync(this._path, options);
    }
    /**
     * Create a new `Path` object relative to the parent directory.
     * @example
     * // "/home/kraih/users.txt"
     * const notes = new Path('/home/kraih/notes.txt');
     * const users = notes.sibling('users.txt');
     */
    sibling(...parts) {
        return this.dirname().child(...parts);
    }
    /**
     * Asynchronously retrieves stat information for the path.
     * @see https://nodejs.org/api/fs.html#fs_fspromises_stat_path_options
     */
    async stat(options) {
        return await fsPromises.stat(this._path, options);
    }
    /**
     * Synchronously retrieves stat information for the path.
     * @see https://nodejs.org/api/fs.html#fs_fs_statsync_path_options
     */
    statSync(options) {
        return fs.statSync(this._path, options);
    }
    /**
     * Asynchronously creates a symbolic link.
     * @see https://nodejs.org/api/fs.html#fs_fspromises_symlink_target_path_type
     */
    async symlink(link, type) {
        await fsPromises.symlink(this._path, link.toString(), type);
        return this;
    }
    /**
     * Synchronously creates a symbolic link.
     * @see https://nodejs.org/api/fs.html#fs_fs_symlinksync_target_path_type
     */
    symlinkSync(link, type) {
        fs.symlinkSync(this._path, link.toString(), type);
        return this;
    }
    /**
     * Asynchronously truncates (shortens or extends the length) of the file.
     * @see https://nodejs.org/api/fs.html#fs_fspromises_truncate_path_len
     */
    async truncate(len) {
        await fsPromises.truncate(this._path, len);
        return this;
    }
    /**
     * Synchronously truncates (shortens or extends the length) of the file.
     * @see https://nodejs.org/api/fs.html#fs_fs_truncatesync_path_len
     */
    truncateSync(len) {
        fs.truncateSync(this._path, len);
        return this;
    }
    /**
     * Create a new `TempDir` object (`Path` subclass with `destroy` and `destroySync` methods) for a temporary directory.
     */
    static async tempDir(options) {
        return await fsPromises.mkdtemp(tempDirPrefix(options?.dir, options?.name), options).then(path => {
            tempDirCleanup.push(path);
            return new TempDir(path);
        });
    }
    /**
     * Create a new `TempDir` object (`Path` subclass with `destroy` and `destroySync` methods) for a temporary directory.
     */
    static tempDirSync(options) {
        const dir = fs.mkdtempSync(tempDirPrefix(options?.dir, options?.name), options);
        tempDirCleanup.push(dir);
        return new TempDir(dir);
    }
    /**
     * Create file if it does not exist or change the modification and access time to the current time.
     */
    async touch() {
        const now = new Date();
        try {
            await fsPromises.utimes(this._path, now, now);
        }
        catch (error) {
            await this.open('w').then(async (value) => await value.close());
        }
        return this;
    }
    /**
     * Create file if it does not exist or change the modification and access time to the current time.
     */
    touchSync() {
        const now = new Date();
        try {
            fs.utimesSync(this._path, now, now);
        }
        catch (error) {
            fs.closeSync(fs.openSync(this._path, 'w'));
        }
        return this;
    }
    /**
     * Split the path.
     */
    toArray() {
        return this._path.split(path.sep);
    }
    /**
     * Convert path into a `file://` `URL` object.
     */
    toFileURL() {
        return url.pathToFileURL(this._path);
    }
    /**
     * Returns an object whose properties represent significant elements of the path.
     */
    toObject() {
        return path.parse(this._path);
    }
    /**
     * Convert path into a string.
     */
    toString() {
        return `${this._path}`;
    }
    /**
     * Change the file system timestamps of the object referenced by path.
     * @see https://nodejs.org/api/fs.html#fs_fspromises_utimes_path_atime_mtime
     */
    async utimes(atime, mtime) {
        await fsPromises.utimes(this._path, atime, mtime);
        return this;
    }
    /**
     * Change the file system timestamps of the object referenced by path.
     * @see https://nodejs.org/api/fs.html#fs_fs_utimessync_path_atime_mtime
     */
    utimesSync(atime, mtime) {
        fs.utimesSync(this._path, atime, mtime);
        return this;
    }
    /**
     * Asynchronously writes data to a file, replacing the file if it already exists.
     * @see https://nodejs.org/api/fs.html#fs_fspromises_writefile_file_data_options
     */
    async writeFile(data, options) {
        await fsPromises.writeFile(this._path, data, options);
        return this;
    }
    /**
     * Synchronously writes data to a file, replacing the file if it already exists.
     * @see https://nodejs.org/api/fs.html#fs_fs_writefilesync_file_data_options
     */
    writeFileSync(data, options) {
        fs.writeFileSync(this._path, data, options);
        return this;
    }
}
class TempDir extends Path {
    /**
     * Asynchronously remove temporary directory.
     */
    async destroy() {
        await fsPromises.rm(this._path, { recursive: true });
        tempDirRemoved(this._path);
    }
    /**
     * Synchronously remove temporary directory.
     */
    destroySync() {
        fs.rmSync(this._path, { recursive: true });
        tempDirRemoved(this._path);
    }
}
function tempDirPrefix(dir, name) {
    return path.join(dir === undefined ? os.tmpdir() : dir.toString(), name ?? 'node-');
}
let tempDirCleanup = [];
function tempDirRemoved(path) {
    tempDirCleanup = tempDirCleanup.filter(tempPath => tempPath !== path);
}
process.on('exit', () => {
    for (const path of tempDirCleanup) {
        try {
            fs.rmSync(path, { recursive: true });
        }
        catch (error) {
            if (!(error instanceof Error) || error.code !== 'ENOENT')
                throw error;
        }
    }
});
//# sourceMappingURL=path.js.map